/*
 * demo_sigio.c
 *
 *  Created on: Jul 14, 2014
 *      Author: mbezold
 */

#include <signal.h>
#include <ctype.h>
#include <fcntl.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <time.h>
#include <mqueue.h>
#include <signal.h>
#include <semaphore.h>
#include "tlpi_hdr.h"
#include "tty_functions.h"
#include "SerialLib8051.h"
#include "SerialDaemon.h"


#include "SerialPacket.h"
#include "SerialMsgUtils.h"


#define SERIAL_FILEPATH "/dev/ttyO4"

#define MAX_READ_BYTES 		255
#define MAX_RX_BUFF_SIZE 	1020

/* Something required by RT Signals
 * is enabled by default */
//#define _POSIX_C_SOURCE 199309


#define DEBUG_LEVEL 21

/* Enables printfs when we have a failure to send */
#define SEND_FAIL 1

/* Display packet processing info such as converted byte count and header length in the Serial8051Send of the code below */
#define PKT_CHARACTERISTICS_DISP 0

/* Builds the file with a main, to facillitate testing of library
 * functions contained herein */
//#define TESTMODE

/* Use to notify the Serial Daemon that it has outgoing data, via a signal sending */
int32_t
SerialDaemonNotify(void){
	sem_t *sem;
	int32_t SerialDaemonPID = 0;
	union sigval sv;

	/* Open the Semaphore that the Serial Daemon creates upon startup */
	sem = sem_open(SERIAL_DAEMON_SEM, 0);

	if(sem == SEM_FAILED){
		#if DEBUG_LEVEL > 10
			printf("SerialDaemonNotify: Failed to Open Sem");
		#endif

		return SEM_OPEN_FAILURE;
	}

	/* Sem Get Value will return the SerialDaemon PID, since the SerialDaemon Assigns
	 * this value to it upon startup */
	if(sem_getvalue(sem, &SerialDaemonPID)==-1){
		#if DEBUG_LEVEL > 10
			errMsg("SerialDaemonNotify: Sem_Getvalue failed");
		#endif

		return SEM_GET_VALUE_FAIL;
	}

	/* Just set to zero, we don't necessarily want to send any data to the functions */
	sv.sival_int = 0;

	/* Send real time signal to SerialDaemon */
	if( sigqueue(SerialDaemonPID, SIGUSR1, sv) == -1 ){
		#if DEBUG_LEVEL > 10
			errMsg("SerialDaemonNotify: sigqueue failed");
		#endif

		return SEM_QUEUE_FAIL;
	}

	/* Close the semaphore, as we don't need it and don't want it registered with the
	 * kernel */
	if(sem_close(sem)==-1){
		#if DEBUG_LEVEL > 10
			errMsg("SerialDaemonNotify: semclose fail");
		#endif

		return SEM_CLOSE_FAIL;

	}


	return 1;
}
/* Call this to initialize the message queue, the first time */
int32_t Serial8051Open(const char* QueueName){
	int32_t flags;
	mode_t perms;
	mqd_t mqd;
	struct mq_attr attr, *attrp;
	attrp = NULL;

	/* Maximum Messages in Msg Queue (fixed for this queue when first created)*/
	attr.mq_maxmsg = MAX_MSG_CNT;

	/* Maximum Per Message Size (fixed when this is first created) Magic 2 is due to ASCII encoding */
	attr.mq_msgsize= 2*MAX_MSG_SIZE + MSG_HEADER_LENGTH;

	/* Pointer to attribute struct, required to pass the struct to mq_open */
		attrp = &attr;

		/* Open for Read Write, Create if not open, Open non-blocking-rcv and send will
		 * fail unless they can complete immediately. */
		flags = O_RDWR | O_CREAT;
		/* Set file permissions everyone can read and write */
		perms = (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);

		mqd=mq_open(QueueName, flags, perms, attrp);

		/* check for fail condition, return to caller */
		if(mqd == (mqd_t) -1){
			#if DEBUG_LEVEL > 10
			errMsg("Serial8051Open: Message Open Failed");
			return MSG_QUEUE_OPEN_FAIL;
			#endif
		}


		return mqd;


} /* Serial8051Open */

/* Pass message to Serial drivers, for output to the 8051
 * Messages are passed to the serial interface through
 * a Msg Queue, which is created here if it doesn't already
 * exist. Input buffer is also converted to an ASCII representation
 * which is suitable for terminal IO

 * INPUTS:
 * TxBuferPass- Raw byte buffer to be transmitted
 * Length- Number of bytes in the buffer
 * MsgID- A component of the header that identifies
 * 	the message type, or delivery endpoint, for higher
 * 	level software

 * RETURNS:
 * Error generated by failed system calls, a negative
 * int defined in SeriaLib8051.h
 */


int32_t Serial8051Send(uint8_t *TxBuffer, int32_t Length, uint8_t MsgID, uint16_t SequenceCount, uint8_t MsgFlags, uint32_t Priority){
	int32_t flags, ASCIIByteCnt = 0, PktHdrLength, SndMsgRtn = 0;
	mqd_t mqd;

	uint8_t *ASCIIHexReturnPntr;
	const char *CompleteMessage;

	/* Initialize packet header struct to use with BuildPacketHdr */
	PacketHdr * CurrentPacketHdr = malloc(MSG_HEADER_LENGTH);


	/* Check for message being too large */
	if(Length > MAX_MSG_SIZE/2){
			#if DEBUG_LEVEL > 10
			errMsg("Serial8051Send: Message is too big for Message Queue");
			#endif

			return OVERSIZE_MSG_ERROR;
	}


	/* Open for Write, Open non-blocking-rcv and send will
	 * fail unless they can complete immediately. */
	flags = O_WRONLY | O_NONBLOCK;


	mqd=mq_open( SERIAL_TX_QUEUE , flags);

	/* check for fail condition, if we failed asssume we need to open a
	 * message queue for the first time, then go ahead and do so
	 * the function below creates a message queue if not already open*/
	if(mqd == (mqd_t) -1){
		mqd=Serial8051Open(SERIAL_TX_QUEUE);

		/* Return an error code now, something bad is happening */
		if(mqd == (mqd_t) -1){
			#if DEBUG_LEVEL > 10
				errMsg("Serial8051Send: Message Open Failed");
			#endif
		return MSG_QUEUE_OPEN_FAIL;
		}

	}

	PktHdrLength= BuildPacketHdr(Length, MsgID, MsgFlags, SequenceCount, CurrentPacketHdr );

	/* Initialize storage for the ASCII hex bytes, multiply by two because
	 * each nibble of the Raw Bytes is represented by an ASCII character,
	 * encoding the hex values */
	ASCIIHexReturnPntr = (uint8_t*)malloc((uint16_t)Length*2);

	/* Convert to ASCII encoding of the hex values representing the raw bytes */
	ASCIIByteCnt = BytesToASCIIHex( TxBuffer, ASCIIHexReturnPntr, Length );

	/* Allocate memory for our Compelete Message (+1 is for the new line character)  */
	CompleteMessage = (const char *) malloc(PktHdrLength+ASCIIByteCnt+1);

	/* Build complete message by combining header with data */
	memcpy((void *)CompleteMessage, (void *)CurrentPacketHdr, (size_t)PktHdrLength );

	/* Adding packet length to CompleteMessage Pointer will drop the data starting in the next byte
	 * address after the last byte in the PacketHeader  */
	memcpy((void *)(CompleteMessage+PktHdrLength), (void *)ASCIIHexReturnPntr, (size_t)ASCIIByteCnt );

	/* Add a new line character at the end  */
	memset( (void *)(CompleteMessage+(PktHdrLength+ASCIIByteCnt)), 0xA ,sizeof(uint8_t) );

	#if PKT_CHARACTERISTICS_DISP == 1
		printf("The Ascii Byte Count is %i \n", ASCIIByteCnt);
		printf("The PktHdrLength is %i \n", PktHdrLength);
	#endif


	SndMsgRtn = mq_send(mqd, CompleteMessage, (PktHdrLength+ASCIIByteCnt+1), Priority);

	if(SndMsgRtn < 0){
		#if SEND_FAIL == 1
			printf("Serial8051Send: Msg Send Fails, Error Code = %i\n", SndMsgRtn);
			errMsg("Serial8051Send");
		#endif
		return MSG_SEND_FAIL;
	}

	/* Free all the pointers we created (including in called functions) to avoid memory leaks */
	free( (void*)CompleteMessage);
	free( (void*)ASCIIHexReturnPntr);
	free( (void*)CurrentPacketHdr);


	if(mq_close(mqd) < (int32_t)0){
		#if DEBUG_LEVEL > 10
		errMsg("Seral8051Send: Close Failed");
		#endif
		return MSG_CLOSE_FAIL;
	}

	return 1;

}

/* Receive message from Serial drivers, from 8051
 * Messages are passed from the serial interface through
 * a Msg Queue, which is created here if it doesn't already
 * exist. Input buffer is also converted from an ASCII to
 * raw bytes

 * INPUTS:
 * RxBuffer- Raw byte buffer to be received
 * CurrentMsgInfo - Pointer to a struct holding message
 * info


 * RETURNS:
 * Bytes received, or Error generated by failed system calls, a negative
 * int defined in SeriaLib8051.h
 */

int32_t Serial8051Receive(uint8_t * RxBuffer, RxMsgInfo * CurrentMsgInfo ){

	int32_t flags = 0;
	ARM_char_t DataIndex;
	mqd_t mqd;
	uint32_t prio;
	struct mq_attr attr;
	ssize_t numRead;

	flags = O_RDWR | O_NONBLOCK;

	/* Open the receive side message queue */
	/*NOTE: In test mode, this is a loopback interface,
	 * with the TX queue, hence the macro*/
	#ifndef TESTMODE
	mqd = mq_open(SERIAL_RX_QUEUE, flags);
	#else
	mqd = mq_open(SERIAL_TX_QUEUE, flags);
	#endif
	if(mqd < (mqd_t) 0){
		#if DEBUG_LEVEL > 10
		errMsg("Serial 8051 Receive: Failed to open receive queue");
		#endif
		return SERIAL_RECEIVE_OPEN_FAILURE;
	}

	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Cleared the Open \n ");
		printf("Serial8051Receive: mqd == %i \n", mqd );
	#endif

	/* Get message attributes for allocating size */
	if(mq_getattr(mqd, &attr) == -1){
		#if DEBUG_LEVEL > 10
		errMsg("Serial 8051 Receive: Failed to get message attributes");
		#endif
		return SERIAL_RECEIVE_MESSAGE_ATTR_FAIL;
	}

	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Cleared the Attributes \n ");
	#endif

	ARM_char_t *ASCII_Buff = (ARM_char_t*) malloc(attr.mq_msgsize);

	if ( ASCII_Buff == NULL){
		#if DEBUG_LEVEL > 10
		printf("Serial 8051 Receive: Failed to allocate buffer \n ");
		#endif
		return SERIAL_RECEIVE_BUFF_ALLOCATE_FAIL;
	}
	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Cleared the malloc \n ");
	#endif

	numRead = mq_receive(mqd, ASCII_Buff, attr.mq_msgsize, &prio);

	if(numRead == -1){
		#if DEBUG_LEVEL > 10
		errMsg("Serial 8051 Receive: Failed to read messages from Rx Queue \n ");
		#endif
		return SERIAL_RECEIVE_MSG_READ_FAIL;
	}

	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Cleared the mqreceive \n ");
	#endif

	if(numRead > 0){

	DataIndex=ProcessPacket( CurrentMsgInfo, ASCII_Buff );

	if ( DataIndex == 0 ){

	#if DEBUG_LEVEL > 20
		printf("Serial 8051 Receive: No header present");

			int32_t i = 0;
			printf("\n mq_receieve: numRead = %i msg size = %i  \n", numRead , attr.mq_msgsize);
			/* Print the raw hex values, for debugging */
			printf("\n ASCII BUFF: ");
				for(i=0; i<numRead; i++){
					printf(" %x ",ASCII_Buff[i]);
				}
			printf("\n");
	#endif // DEBUG_LEVEL > 20

		return SERIAL_RECEIVE_NO_HEADER_FAIL;
	}

	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Cleared the ProcessPacket \n ");
	#endif // DEBUG_LEVEL > 15

	/* Set Data Pointer to the the starting address of ASCII_Buff, plus the
	 * 13 to account for the header, we just want to have ASCII HEX to Bytes
	 * convert the data portion of the message, not the header */
	/*DataPointer = &ASCII_Buff[0] + MSG_HEADER_LENGTH; */


	/* Convert from ASCII encoding back to raw bytes
	 * function requires number of ascii bytes, hence the multiply by 2 */

	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Current Message Length == %u \n ", CurrentMsgInfo->MsgLength);
	#endif

	ASCIIHexToBytes( &ASCII_Buff[MSG_HEADER_LENGTH], RxBuffer, (CurrentMsgInfo->MsgLength) * 2 );

	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Cleared ASCIIHexToBytes\n ");
	#endif

	}

	free(ASCII_Buff);

	/* Close message queue before returning */
	if(mq_close(mqd) < (int32_t)0){
			errMsg("Seral8051Receive: Close Failed\n");
	}

	#if DEBUG_LEVEL > 15
		printf("Serial8051Receive: Cleared the mq_close\n ");
	#endif

	return numRead;
}

#ifdef TESTMODE

int
main(int argc, char *argv[])
{


	int32_t i = 0, readBytes=0, writeBytes = 0;
	int32_t inputFd, outputFd;


	uint8_t MsgDataIndex = 48;

	/* Buffer for FILE I/O for test purposes */
	uint8_t FileOutputBuffer[FILE_OUT_BUFF_SIZE]={0};

	printf("SerialLib Test Mode: Executing \n");

	/* Close Serial Queue before reopening it */
	mq_unlink(SERIAL_TX_QUEUE);


	/* Open for Writing */
	inputFd = open(TEST_INPUT_FILENAME, O_RDWR| O_CREAT | O_APPEND,
				S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);

	/* Fill the Output Buffer */
	for(i = 0 ; i < FILE_OUT_BUFF_SIZE; i++){

		/* Every 3rd byte is a char counter */
		if(i % 3 == 1){
			FileOutputBuffer[i] = MsgDataIndex;
			MsgDataIndex++;

			/* Reset to ASCII 0-9 */
			if(MsgDataIndex == 58){
				MsgDataIndex = 48;
			}

		}
		else{
			FileOutputBuffer[i] = 64;
		}

	}

	/* Write out data to file */
	write(inputFd, FileOutputBuffer, FILE_OUT_BUFF_SIZE);

	if(close(inputFd)==-1)
			errExit("close output file failed");

	/* Delay, for the hell of it */
	sleep(1);


	/* Allocate  TxMsg Buffers */
	uint8_t *TxMsg1 = (uint8_t*)malloc(FILE_OUT_BUFF_SIZE);
	uint8_t *TxMsg2 = (uint8_t*)malloc(FILE_OUT_BUFF_SIZE/3);
	uint8_t *TxMsg3 = (uint8_t*)malloc(FILE_OUT_BUFF_SIZE/3);
	uint8_t *TxMsg4 = (uint8_t*)malloc(FILE_OUT_BUFF_SIZE/10);

	/* InitializeBuffers to Some known values */
	memset( (void*) TxMsg1, 0xAA, FILE_OUT_BUFF_SIZE);
	memset( (void*) TxMsg2, 0xAA, FILE_OUT_BUFF_SIZE/3);
	memset( (void*) TxMsg3, 0xAA, FILE_OUT_BUFF_SIZE/3);
	memset( (void*) TxMsg1, 0xAA, FILE_OUT_BUFF_SIZE/10);

	printf("SerialLib Test Mode: Cleared first memset\n");

	int32_t Msg1Len=FILE_OUT_BUFF_SIZE;
	int32_t Msg2Len=FILE_OUT_BUFF_SIZE/3;
	int32_t Msg3Len=FILE_OUT_BUFF_SIZE/3;
	int32_t Msg4Len=FILE_OUT_BUFF_SIZE/10;

	uint8_t Msg1ID=9;
	uint8_t Msg2ID=207;
	uint8_t Msg3ID=13;
	uint8_t Msg4ID=128;

	uint16_t Msg1SeqCnt = 17896;
	uint16_t Msg2SeqCnt = 276;
	uint16_t Msg3SeqCnt = 32 ;
	uint16_t Msg4SeqCnt = 0;

	/* Open for Reading */
	inputFd = open(TEST_INPUT_FILENAME, O_RDWR| O_CREAT | O_APPEND,
				S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
	if(inputFd == -1)
		errExit("Input File Open Failed");
	/* Get data for Msg1 from input file  */
	readBytes = read(inputFd, (void *)TxMsg1, (size_t) Msg1Len );

	if(readBytes < 1)
		printf("Msg1: Error, or EOF encountered");

	/* Get data for Msg2 from input file  */
	readBytes = read(inputFd, (void *)TxMsg2, (size_t) Msg2Len );

	if(readBytes < 1)
		printf("Msg2: Error, or EOF encountered");

	/* Get data for Msg3 from input file  */
	readBytes = read(inputFd, (void *)TxMsg3, (size_t) Msg3Len );

	if(readBytes < 1)
		printf("Msg3: Error, or EOF encountered");

	/* Get data for Msg4 from input file
	 * First, move the file offset (via lseek) to the middle of the file
	 * (negative half the total of number bytes from the end,
	 * as specified by SEEK_END   */
	off_t CurrentOffset = lseek(inputFd, -FILE_OUT_BUFF_SIZE/2, SEEK_END);
	readBytes = read(inputFd, (void *)TxMsg4, (size_t) Msg4Len );

	printf("SerialLib Test Mode: lseek and read iput cleared \n");
	if(readBytes < 1)
		errMsg("Msg4: Error, or EOF encountered");

	/* Open QUEUE for the first time */
	Serial8051Open(SERIAL_TX_QUEUE);

	printf("SerialLib Test Mode: Cleared Message Queue open \n");


	/* Send Message 1 */
	Serial8051Send(TxMsg1, Msg1Len, Msg1ID, Msg1SeqCnt, 37, 0 );

	sleep(1);

	/* Send Message 2 */
	Serial8051Send(TxMsg2, Msg2Len, Msg2SeqCnt, 276, 37, 0  );

	sleep(1);


	/* Send Message 3 */
	Serial8051Send(TxMsg2, Msg3Len, Msg3SeqCnt, 32, 37, 0  );

	sleep(1);

	/* Send Message 4 */
	Serial8051Send(TxMsg2, Msg4Len, Msg4SeqCnt, 0, 37, 0  );

	sleep(1);

	if(close(inputFd)==-1)
			errExit("close input file failed");

	printf("SerialLib Test Mode: Cleared Message Sends \n");


	sleep(1);

	/* Open our file for saving the received data buffer */
	/* Open for Writing */
	outputFd = open(TEST_OUPUT_FILENAME, O_RDWR| O_CREAT | O_APPEND,
					S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);

	if(outputFd == -1)
		errMsg("Output File Open Failed");


	/* Allocate  RxMsg Buffers (magic number '2' is for a new line character
	 * and a null byte to be added to facillitate display/debug */
	uint8_t *RxMsg1 = (uint8_t*)malloc((4*FILE_OUT_BUFF_SIZE));
	uint8_t *RxMsg2 = (uint8_t*)malloc((4*FILE_OUT_BUFF_SIZE));
	uint8_t *RxMsg3 = (uint8_t*)malloc((4*FILE_OUT_BUFF_SIZE));
	uint8_t *RxMsg4 = (uint8_t*)malloc((4*FILE_OUT_BUFF_SIZE));


	RxMsgInfo *Msg1Info = (RxMsgInfo*) malloc (sizeof(RxMsgInfo));
	RxMsgInfo *Msg2Info = (RxMsgInfo*) malloc (sizeof(RxMsgInfo));
	RxMsgInfo *Msg3Info = (RxMsgInfo*) malloc (sizeof(RxMsgInfo));
	RxMsgInfo *Msg4Info = (RxMsgInfo*) malloc (sizeof(RxMsgInfo));

	printf("SerialLib Test Mode: Cleared Receive Queue Mallocs \n");

	/* InitializeBuffers to Some known values */
	memset( (void*) RxMsg1, 0xBB, 4*FILE_OUT_BUFF_SIZE);
	memset( (void*) RxMsg2, 0xBB, 4*FILE_OUT_BUFF_SIZE);
	memset( (void*) RxMsg3, 0xBB, 4*FILE_OUT_BUFF_SIZE);
	memset( (void*) RxMsg4, 0xBB, 4*FILE_OUT_BUFF_SIZE);

	printf("SerialLib Test Mode: Cleared Receive Queue Memesets \n");
	/* Receive Msg1  */
	readBytes = Serial8051Receive(RxMsg1, Msg1Info);

	printf(" RxMsg1: Read bytes Read Bytes = %i Msg1Len = %i \n", readBytes, Msg1Len );


	if(readBytes != Msg1Len){
		printf("RxMsg1: Incorrect Number of bytes received. Read Bytes = %i Msg1Len = %i \n", readBytes, Msg1Len );
	/*	printf("\n Read Buff: ");
				for(i=0; i<((FILE_OUT_BUFF_SIZE/3)+2); i++){
							printf(" %x",RxMsg1[i]);
					}
				printf("\n"); */
	}

	if(Msg1Info->MsgLength != readBytes)
		errMsg("RxMsg1: Size mismatch between Read Bytes and MsgLength");

	/*Format RxMsg1 with a new line char to make it more suitable for
	 * display  */
	RxMsg1[Msg1Info->MsgLength+1]='\n';
	/* A Null character */
	RxMsg1[Msg1Info->MsgLength+2]= 0x00;

	if(readBytes < 0)
		errMsg("Rx Msg1 Failed");

	 ARM_char_t StructContents1[1000];

	if(readBytes>0){
		sprintf(StructContents1, "Message 1: \n (From Struct) Length: %u, MsgFlags: %c Sequence Count %u MsgID: %c  Message Content: \n", Msg1Info->MsgLength, Msg1Info->MsgFlags, Msg1Info->SeqCount, Msg1Info->MsgID);
		writeBytes = write(outputFd, StructContents1, strlen(StructContents1));

		if(writeBytes<0)
			errMsg("RxMsg1: First write failed");

		writeBytes = write( outputFd, RxMsg1,readBytes);

		if(writeBytes<0)
			errMsg("RxMsg1: Second write failed");

	}

	/* Receive Msg1  */
	readBytes = Serial8051Receive(RxMsg2, Msg2Info);

	printf(" RxMsg2: Read bytes Read Bytes = %i Msg1Len = %i \n", readBytes, Msg1Len );

	if(readBytes != Msg2Len)
		errMsg("RxMsg2: Incorrect Number of bytes received");

	if(Msg1Info->MsgLength != readBytes)
		errMsg("RxMsg2: Size mismatch between Read Bytes and MsgLength");

	/*Format RxMsg1 with a new line char to make it more suitable for
	 * display  */
	RxMsg2[Msg2Info->MsgLength+1]='\n';
	/* A null character */
	RxMsg2[Msg2Info->MsgLength+2]=0x00;

	if(readBytes < 0)
		errMsg("Rx Msg2 Failed");

	ARM_char_t StructContents2[1000];

	if(readBytes>0){
		sprintf(StructContents2, "Message 2: \n (From Struct) Length: %u, MsgFlags: %c Sequence Count %u MsgID: %c  Message Content: \n", Msg1Info->MsgLength, Msg1Info->MsgFlags, Msg1Info->SeqCount, Msg1Info->MsgID);
		writeBytes = write(outputFd, StructContents2, strlen(StructContents2));

		if(writeBytes<=0)
			errMsg("RxMsg2: First write failed");

		writeBytes = write( outputFd, RxMsg2,readBytes);

		if(writeBytes<=0)
			errMsg("RxMsg2: Second write failed");

	}


	/* Receive Msg3  */
	readBytes = Serial8051Receive(RxMsg3, Msg3Info);

	printf(" RxMsg3: Read bytes Read Bytes = %i Msg1Len = %u \n", readBytes, Msg1Len );

	if(readBytes != Msg3Len)
		printf("RxMsg3: Incorrect Number of bytes received");

	if(Msg3Info->MsgLength != readBytes)
		printf("RxMsg3: Size mismatch between Read Bytes and MsgLength");

	/*Format RxMsg1 with a new line char to make it more suitable for
	 * display  */
	RxMsg3[Msg3Info->MsgLength+1]='\n';
	RxMsg3[Msg3Info->MsgLength+2]=0x00;

	if(readBytes < 0)
		errMsg("Rx Msg3 Failed");

	ARM_char_t StructContents3[1000];

	if(readBytes>0){
		sprintf(StructContents3, "Message 3: \n (From Struct) Length: %u, MsgFlags: %c Sequence Count %u MsgID: %c  Message Content: \n", Msg1Info->MsgLength, Msg1Info->MsgFlags, Msg1Info->SeqCount, Msg1Info->MsgID);
		writeBytes = write(outputFd, StructContents3, strlen(StructContents3));

		if(writeBytes<=0)
			printf("RxMsg3: First write failed");

		writeBytes = write( outputFd, RxMsg3,readBytes);

		if(writeBytes<=0)
			printf("RxMsg3: Second write failed");

	}


	/* Receive Msg4  */
	readBytes = Serial8051Receive(RxMsg4, Msg4Info);

	printf(" RxMsg4: Reab bytes Read Bytes = %i Msg1Len = %i \n", readBytes, Msg1Len );

	if(readBytes != Msg4Len)
		printf("RxMsg4: Incorrect Number of bytes received");

	if(Msg4Info->MsgLength != readBytes)
		printf("RxMsg4: Size mismatch between Read Bytes and MsgLength");

	/*Format RxMsg1 with a new line char to make it more suitable for
	 * display  */
	RxMsg4[Msg4Info->MsgLength+1]='\n';
	RxMsg4[Msg4Info->MsgLength+2]=0x00;

	if(readBytes < 0)
		printf("Rx Msg4 Failed");

	ARM_char_t StructContents4[1000];

	if(readBytes>0){
		int32_t WrittenBytes=sprintf(StructContents4, "Message 4: \n (From Struct) Length: %u, MsgFlags: %c Sequence Count %u MsgID: %c  Message Content: \n", Msg1Info->MsgLength, Msg1Info->MsgFlags, Msg1Info->SeqCount, Msg1Info->MsgID);
		writeBytes = write(outputFd, StructContents4, strlen(StructContents4));

		if(WrittenBytes < 0){
			printf("Msg4: snprintf Bytes Failed \n");
		}

		if(writeBytes<=0)
			printf("RxMsg4: First write failed");

		writeBytes = write( outputFd, RxMsg4 ,readBytes);

		if(writeBytes<0)
			printf("RxMsg4: Second write failed");

	}

	close(outputFd);

	/* Remove TX Queue after we close */
	mq_unlink(SERIAL_TX_QUEUE);
	printf("Exiting Serial Daemon \n");
	exit(EXIT_SUCCESS);
}

#endif /* testmode */
